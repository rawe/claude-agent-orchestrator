#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "httpx>=0.25.0",
#     "typer>=0.9.0",
#     "uvicorn>=0.30.0",
#     "starlette>=0.38.0",
#     "mcp>=1.0.0",
#     "fastmcp>=2.0.0",
# ]
# ///
"""
Agent Runner - Connects to Agent Coordinator and executes agent runs.

The runner polls for agent runs from Agent Coordinator and spawns executor
subprocesses to handle them. It supports concurrent agent run execution
and reports run status back to the coordinator.

Usage:
    ./servers/agent-runner/agent-runner --profile coding

Environment Variables:
    AGENT_ORCHESTRATOR_API_URL - Agent Coordinator URL (default: http://localhost:8765)
    POLL_TIMEOUT         - Long-poll timeout in seconds (default: 30)
    HEARTBEAT_INTERVAL   - Heartbeat interval in seconds (default: 60)
    PROJECT_DIR          - Default project directory (default: cwd)
"""

import os
import sys
import signal
import socket
import time
import threading
import logging
from dataclasses import asdict
from pathlib import Path

# Configure UTF-8 encoding for Windows console (handles emojis in subprocess output)
# errors='replace' ensures graceful fallback on older consoles
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8', errors='replace')
    sys.stderr.reconfigure(encoding='utf-8', errors='replace')

# Add lib to path for service modules
sys.path.insert(0, str(Path(__file__).parent / "lib"))

import typer
from config import RunnerConfig
from api_client import CoordinatorAPIClient, DuplicateRunnerError, AgentNameCollisionError, AuthenticationError
from auth0_client import Auth0M2MClient
from registry import RunningRunsRegistry
from executor import (
    RunExecutor,
    list_profiles,
    load_profile,
    load_agents_from_profile,
    ExecutorProfile,
    DEFAULT_EXECUTOR_PATH,
    DEFAULT_EXECUTOR_TYPE,
)
from poller import RunPoller
from supervisor import RunSupervisor
from runner_gateway import RunnerGateway
from blueprint_resolver import BlueprintResolver
from agent_orchestrator_mcp import MCPServer

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger("agent-runner")

# Keep HTTP client loggers quiet (only warnings) - even in verbose mode
# These are too low-level for normal debugging
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("httpcore").setLevel(logging.WARNING)

app = typer.Typer(add_completion=False)


class HeartbeatThread:
    """Background thread that sends periodic heartbeats."""

    def __init__(
        self,
        api_client: CoordinatorAPIClient,
        runner_id: str,
        interval: int,
    ):
        self.api_client = api_client
        self.runner_id = runner_id
        self.interval = interval
        self._thread: threading.Thread | None = None
        self._stop_event = threading.Event()

    def start(self) -> None:
        """Start the heartbeat thread."""
        self._stop_event.clear()
        self._thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        self._thread.start()
        logger.info(f"Heartbeat started (interval={self.interval}s)")

    def stop(self) -> None:
        """Stop the heartbeat thread."""
        self._stop_event.set()
        if self._thread:
            self._thread.join(timeout=5.0)
            self._thread = None
        logger.info("Heartbeat stopped")

    def _heartbeat_loop(self) -> None:
        """Send heartbeats periodically."""
        while not self._stop_event.wait(self.interval):
            try:
                self.api_client.heartbeat(self.runner_id)
                logger.info("Heartbeat sent to agent-coordinator")
            except Exception as e:
                logger.warning(f"Heartbeat to agent-coordinator failed: {e}")


class Runner:
    """Main runner orchestrator."""

    def __init__(self, config: RunnerConfig):
        self.config = config

        # Create Auth0 client if configured
        self.auth0_client: Auth0M2MClient | None = None
        if config.use_oidc:
            self.auth0_client = Auth0M2MClient(
                domain=config.auth0_domain,
                client_id=config.auth0_client_id,
                client_secret=config.auth0_client_secret,
                audience=config.auth0_audience,
            )
            logger.info("Auth0 M2M authentication enabled")

        self.api_client = CoordinatorAPIClient(
            config.agent_coordinator_url,
            auth0_client=self.auth0_client,
            timeout=config.poll_timeout + 5.0,  # Slightly longer than poll timeout
        )

        # Runner-owned data (used by gateway to enrich executor requests)
        self._hostname = socket.gethostname()

        # Determine executor profile name
        if config.profile:
            self._executor_profile = config.profile.name
        else:
            self._executor_profile = DEFAULT_EXECUTOR_TYPE

        # Create gateway for executor communication
        # Executors connect to this gateway instead of the coordinator directly
        # The gateway handles authentication and enriches requests with runner data
        self.gateway = RunnerGateway(
            coordinator_url=config.agent_coordinator_url,
            auth0_client=self.auth0_client,
            hostname=self._hostname,
            executor_profile=self._executor_profile,
        )

        # Create embedded MCP server - facade to Coordinator
        # Provides orchestration tools to agents running in executors
        # IMPORTANT: auth0_client is passed by reference to share token cache
        # This avoids duplicate M2M token requests - the MCP server reuses our token
        self.mcp_server = MCPServer(
            coordinator_url=config.agent_coordinator_url,
            auth0_client=self.auth0_client,  # Shared instance for token reuse
            port=config.mcp_port,  # Optional fixed port from CLI
        )

        # Create blueprint resolver for Schema 2.0
        # Fetches and resolves blueprints before passing to executor
        self.blueprint_resolver = BlueprintResolver(
            coordinator_url=config.agent_coordinator_url,
            auth0_client=self.auth0_client,
        )

        self.registry = RunningRunsRegistry()
        # Note: mcp_server_url will be set after mcp_server.start() in start()
        self.executor = RunExecutor(
            default_project_dir=config.project_dir,
            profile=config.profile,
            blueprint_resolver=self.blueprint_resolver,
            mcp_server_url=None,
        )
        self.runner_id: str | None = None

        self.poller: RunPoller | None = None
        self.supervisor: RunSupervisor | None = None
        self.heartbeat: HeartbeatThread | None = None

        self._shutdown_event = threading.Event()
        self._externally_deregistered = False  # True if shutdown was triggered by external deregistration

    def register(self) -> None:
        """Register with Agent Coordinator."""
        logger.info(f"Connecting to Agent Coordinator at {self.config.agent_coordinator_url}")

        # Determine executor info for registration
        # Use asdict() to serialize all profile fields except 'name' (sent as executor_profile)
        if self.config.profile:
            executor = {k: v for k, v in asdict(self.config.profile).items() if k != "name"}
        else:
            # Default: no profile specified
            executor = {
                "type": DEFAULT_EXECUTOR_TYPE,
                "command": DEFAULT_EXECUTOR_PATH,
                "config": {},
            }

        # Load runner-owned agents from profile (Phase 4 - Procedural Executor)
        agents = None
        if self.config.profile:
            agents = load_agents_from_profile(self.config.profile)
            if agents:
                logger.info(f"Loaded {len(agents)} agents from profile")

        try:
            response = self.api_client.register(
                hostname=self._hostname,
                project_dir=self.config.project_dir,
                executor_profile=self._executor_profile,
                executor=executor,
                tags=self.config.tags if self.config.tags else None,
                require_matching_tags=self.config.require_matching_tags,
                agents=agents,
            )
            self.runner_id = response.runner_id
            logger.info(f"Registered as {self.runner_id}")
            logger.info(f"  Hostname: {self._hostname}")
            logger.info(f"  Executor profile: {self._executor_profile}")
            logger.info(f"  Executor type: {executor['type']}")
            logger.info(f"  Poll timeout: {response.poll_timeout_seconds}s")
            logger.info(f"  Heartbeat interval: {response.heartbeat_interval_seconds}s")
            logger.info(f"  Project directory: {self.config.project_dir}")
            if self.config.tags:
                logger.info(f"  Tags: {self.config.tags}")
            if self.config.require_matching_tags:
                logger.info(f"  Require matching tags: {self.config.require_matching_tags}")
            if agents:
                logger.info(f"  Agents: {[a['name'] for a in agents]}")
        except AuthenticationError as e:
            logger.error(f"Authentication failed: {e}")
            raise SystemExit(1)
        except Exception as e:
            logger.error(f"Failed to register: {e}")
            raise

    def start(self) -> None:
        """Start all background threads."""
        if not self.runner_id:
            raise RuntimeError("Must register before starting")

        # Start the gateway server for executor communication
        # This must happen before spawning any executors
        self.gateway.start()

        # Set environment variable so executors use the gateway
        os.environ["AGENT_ORCHESTRATOR_API_URL"] = self.gateway.url

        # Start embedded MCP server
        # Provides orchestration tools to agents running in executors
        self.mcp_server.start()
        logger.info(f"Embedded MCP server on port {self.mcp_server.port}")

        # Update executor with MCP server URL for placeholder resolution
        self.executor.mcp_server_url = self.mcp_server.url

        # Create components
        self.poller = RunPoller(
            self.api_client,
            self.executor,
            self.registry,
            self.runner_id,
            on_deregistered=self._on_external_deregistration,
        )

        self.supervisor = RunSupervisor(
            self.api_client,
            self.registry,
            self.runner_id,
        )

        self.heartbeat = HeartbeatThread(
            self.api_client,
            self.runner_id,
            self.config.heartbeat_interval,
        )

        # Start threads
        self.poller.start()
        self.supervisor.start()
        self.heartbeat.start()

        logger.info("Runner started - waiting for agent runs")

    def _on_external_deregistration(self) -> None:
        """Called when runner is deregistered externally (e.g., from dashboard)."""
        logger.warning("Runner was deregistered externally - shutting down")
        self._externally_deregistered = True
        self.shutdown()

    def stop(self) -> None:
        """Stop all background threads and deregister from Agent Coordinator."""
        logger.info("Stopping runner...")

        if self.poller:
            self.poller.stop()
        if self.supervisor:
            self.supervisor.stop()
        if self.heartbeat:
            self.heartbeat.stop()

        # Stop the embedded MCP server
        self.mcp_server.stop()

        # Stop the gateway server
        self.gateway.stop()

        # Deregister from Agent Coordinator (only if not already deregistered externally)
        if self.runner_id and not self._externally_deregistered:
            self.api_client.deregister(self.runner_id)

        self.api_client.close()
        logger.info("Runner stopped")

    def wait_for_shutdown(self) -> None:
        """Wait for shutdown signal."""
        self._shutdown_event.wait()

    def shutdown(self) -> None:
        """Signal shutdown."""
        self._shutdown_event.set()


@app.command()
def main(
    coordinator_url: str = typer.Option(
        None,
        "--coordinator-url",
        "-c",
        help="Agent Coordinator URL (env: AGENT_ORCHESTRATOR_API_URL)",
    ),
    profile: str = typer.Option(
        None,
        "--profile",
        "-x",
        help="Executor profile name (loads profiles/<name>.json)",
    ),
    profile_list: bool = typer.Option(
        False,
        "--profile-list",
        "-l",
        help="List available profiles and exit",
    ),
    require_matching_tags: bool = typer.Option(
        False,
        "--require-matching-tags",
        help="Only accept runs with at least one matching tag",
    ),
    project_dir: str = typer.Option(
        None,
        "--project-dir",
        "-p",
        help="Default project directory (env: PROJECT_DIR)",
    ),
    tags: str = typer.Option(
        None,
        "--tags",
        "-t",
        help="Comma-separated capability tags (env: RUNNER_TAGS). E.g., 'python,docker,nodejs'",
    ),
    verbose: bool = typer.Option(
        False,
        "--verbose",
        "-v",
        help="Enable verbose logging",
    ),
    mcp_port: int = typer.Option(
        None,
        "--mcp-port",
        "-m",
        help="Port for embedded MCP server (default: random available port)",
    ),
):
    """
    Agent Runner - Execute agent runs from Agent Coordinator.

    Polls Agent Coordinator for agent runs and spawns executor subprocesses to handle them.
    Supports concurrent agent run execution.
    """
    # Handle --profile-list
    if profile_list:
        profiles = list_profiles()
        if profiles:
            print("Available profiles:")
            for name in profiles:
                print(f"  {name}")
        else:
            print("No profiles found in profiles/ directory")
        raise typer.Exit(0)

    # Load config
    config = RunnerConfig.from_env()

    # Override with CLI args
    if coordinator_url:
        config.agent_coordinator_url = coordinator_url
    if project_dir:
        config.project_dir = project_dir
    if tags:
        config.tags = [tag.strip() for tag in tags.split(",") if tag.strip()]
    if mcp_port:
        config.mcp_port = mcp_port
    if require_matching_tags:
        config.require_matching_tags = require_matching_tags

    # Load profile if specified
    if profile:
        try:
            config.profile = load_profile(profile)
            logger.info(f"Loaded profile '{profile}' (executor: {config.profile.type})")
        except RuntimeError as e:
            logger.error(str(e))
            raise typer.Exit(1)

    # Set log level
    if verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Create runner
    runner = Runner(config)

    # Setup signal handlers
    def handle_signal(signum, frame):
        logger.info(f"Received signal {signum}")
        runner.shutdown()

    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    try:
        # Register and start
        runner.register()
        runner.start()

        # Wait for shutdown
        runner.wait_for_shutdown()

    except DuplicateRunnerError as e:
        logger.error("=" * 60)
        logger.error("DUPLICATE RUNNER ERROR")
        logger.error("=" * 60)
        logger.error(f"A runner with this identity is already online:")
        logger.error(f"  Runner ID:        {e.runner_id}")
        logger.error(f"  Hostname:         {e.hostname}")
        logger.error(f"  Project Dir:      {e.project_dir}")
        logger.error(f"  Executor Profile: {e.executor_profile}")
        logger.error("")
        logger.error("Each unique combination of (hostname, project_dir, executor_profile)")
        logger.error("can only have one active runner at a time.")
        logger.error("")
        logger.error("Options:")
        logger.error("  1. Use a different --project-dir for the second runner")
        logger.error("  2. Stop the existing runner first")
        logger.error("  3. Deregister the existing runner from the dashboard")
        logger.error("=" * 60)
        sys.exit(1)
    except AgentNameCollisionError as e:
        logger.error("=" * 60)
        logger.error("AGENT NAME COLLISION ERROR")
        logger.error("=" * 60)
        logger.error(f"Cannot register agent - name already taken by another runner:")
        logger.error(f"  Agent Name:         {e.agent_name}")
        logger.error(f"  Existing Runner ID: {e.existing_runner_id}")
        logger.error("")
        logger.error("Each agent name can only be registered by one runner at a time.")
        logger.error("")
        logger.error("Options:")
        logger.error("  1. Rename your agent to avoid the collision")
        logger.error("  2. Stop the runner that owns the existing agent")
        logger.error("  3. Wait for the existing runner to disconnect")
        logger.error("=" * 60)
        sys.exit(1)
    except KeyboardInterrupt:
        logger.info("Interrupted")
    except Exception as e:
        logger.error(f"Error: {e}")
        sys.exit(1)
    finally:
        runner.stop()


if __name__ == "__main__":
    app()
