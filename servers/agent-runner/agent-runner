#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "httpx>=0.25.0",
#     "typer>=0.9.0",
# ]
# ///
"""
Agent Runner - Connects to Agent Coordinator and executes agent runs.

The runner polls for agent runs from Agent Coordinator and spawns executor
subprocesses to handle them. It supports concurrent agent run execution
and reports run status back to the coordinator.

Usage:
    ./servers/agent-runner/agent-runner

Environment Variables:
    AGENT_ORCHESTRATOR_API_URL - Agent Coordinator URL (default: http://localhost:8765)
    AGENT_EXECUTOR_PATH  - Executor script path (default: executors/claude-code/ao-claude-code-exec)
    POLL_TIMEOUT         - Long-poll timeout in seconds (default: 30)
    HEARTBEAT_INTERVAL   - Heartbeat interval in seconds (default: 60)
    PROJECT_DIR          - Default project directory (default: cwd)
"""

import os
import sys
import signal
import socket
import time
import threading
import logging
from pathlib import Path

# Configure UTF-8 encoding for Windows console (handles emojis in subprocess output)
# errors='replace' ensures graceful fallback on older consoles
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8', errors='replace')
    sys.stderr.reconfigure(encoding='utf-8', errors='replace')

# Add lib to path for service modules
sys.path.insert(0, str(Path(__file__).parent / "lib"))

import typer
from config import RunnerConfig
from api_client import CoordinatorAPIClient, DuplicateRunnerError, AuthenticationError
from auth0_client import Auth0M2MClient
from registry import RunningRunsRegistry
from executor import RunExecutor, list_executors, resolve_executor_name, get_executor_type
from poller import RunPoller
from supervisor import RunSupervisor
from coordinator_proxy import CoordinatorProxy
from blueprint_resolver import BlueprintResolver

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger("agent-runner")

# Keep HTTP client loggers quiet (only warnings) - even in verbose mode
# These are too low-level for normal debugging
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("httpcore").setLevel(logging.WARNING)

app = typer.Typer(add_completion=False)


class HeartbeatThread:
    """Background thread that sends periodic heartbeats."""

    def __init__(
        self,
        api_client: CoordinatorAPIClient,
        runner_id: str,
        interval: int,
    ):
        self.api_client = api_client
        self.runner_id = runner_id
        self.interval = interval
        self._thread: threading.Thread | None = None
        self._stop_event = threading.Event()

    def start(self) -> None:
        """Start the heartbeat thread."""
        self._stop_event.clear()
        self._thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        self._thread.start()
        logger.info(f"Heartbeat started (interval={self.interval}s)")

    def stop(self) -> None:
        """Stop the heartbeat thread."""
        self._stop_event.set()
        if self._thread:
            self._thread.join(timeout=5.0)
            self._thread = None
        logger.info("Heartbeat stopped")

    def _heartbeat_loop(self) -> None:
        """Send heartbeats periodically."""
        while not self._stop_event.wait(self.interval):
            try:
                self.api_client.heartbeat(self.runner_id)
                logger.info("Heartbeat sent to agent-coordinator")
            except Exception as e:
                logger.warning(f"Heartbeat to agent-coordinator failed: {e}")


class Runner:
    """Main runner orchestrator."""

    def __init__(self, config: RunnerConfig):
        self.config = config

        # Create Auth0 client if configured
        self.auth0_client: Auth0M2MClient | None = None
        if config.use_oidc:
            self.auth0_client = Auth0M2MClient(
                domain=config.auth0_domain,
                client_id=config.auth0_client_id,
                client_secret=config.auth0_client_secret,
                audience=config.auth0_audience,
            )
            logger.info("Auth0 M2M authentication enabled")

        self.api_client = CoordinatorAPIClient(
            config.agent_coordinator_url,
            auth0_client=self.auth0_client,
            timeout=config.poll_timeout + 5.0,  # Slightly longer than poll timeout
        )

        # Create proxy for executor communication
        # Executors connect to this proxy instead of the coordinator directly
        # The proxy handles authentication transparently
        self.proxy = CoordinatorProxy(
            coordinator_url=config.agent_coordinator_url,
            auth0_client=self.auth0_client,
        )

        # Create blueprint resolver for Schema 2.0
        # Fetches and resolves blueprints before passing to executor
        self.blueprint_resolver = BlueprintResolver(
            coordinator_url=config.agent_coordinator_url,
            auth0_client=self.auth0_client,
        )

        self.registry = RunningRunsRegistry()
        self.executor = RunExecutor(
            default_project_dir=config.project_dir,
            blueprint_resolver=self.blueprint_resolver,
            mcp_server_url=None,  # Will be set when embedded MCP server is implemented
        )
        self.runner_id: str | None = None

        self.poller: RunPoller | None = None
        self.supervisor: RunSupervisor | None = None
        self.heartbeat: HeartbeatThread | None = None

        self._shutdown_event = threading.Event()
        self._externally_deregistered = False  # True if shutdown was triggered by external deregistration

    def register(self) -> None:
        """Register with Agent Coordinator."""
        logger.info(f"Connecting to Agent Coordinator at {self.config.agent_coordinator_url}")

        # Get machine hostname and executor type for registration metadata
        hostname = socket.gethostname()
        executor_type = get_executor_type()

        try:
            response = self.api_client.register(
                hostname=hostname,
                project_dir=self.config.project_dir,
                executor_type=executor_type,
                tags=self.config.tags if self.config.tags else None,
            )
            self.runner_id = response.runner_id
            logger.info(f"Registered as {self.runner_id}")
            logger.info(f"  Hostname: {hostname}")
            logger.info(f"  Executor type: {executor_type}")
            logger.info(f"  Poll timeout: {response.poll_timeout_seconds}s")
            logger.info(f"  Heartbeat interval: {response.heartbeat_interval_seconds}s")
            logger.info(f"  Project directory: {self.config.project_dir}")
            if self.config.tags:
                logger.info(f"  Tags: {self.config.tags}")
        except AuthenticationError as e:
            logger.error(f"Authentication failed: {e}")
            raise SystemExit(1)
        except Exception as e:
            logger.error(f"Failed to register: {e}")
            raise

    def start(self) -> None:
        """Start all background threads."""
        if not self.runner_id:
            raise RuntimeError("Must register before starting")

        # Start the proxy server for executor communication
        # This must happen before spawning any executors
        self.proxy.start()

        # Set environment variable so executors use the proxy
        # This is transparent - executors don't know they're using a proxy
        os.environ["AGENT_ORCHESTRATOR_API_URL"] = self.proxy.url

        # Create components
        self.poller = RunPoller(
            self.api_client,
            self.executor,
            self.registry,
            self.runner_id,
            on_deregistered=self._on_external_deregistration,
        )

        self.supervisor = RunSupervisor(
            self.api_client,
            self.registry,
            self.runner_id,
        )

        self.heartbeat = HeartbeatThread(
            self.api_client,
            self.runner_id,
            self.config.heartbeat_interval,
        )

        # Start threads
        self.poller.start()
        self.supervisor.start()
        self.heartbeat.start()

        logger.info("Runner started - waiting for agent runs")

    def _on_external_deregistration(self) -> None:
        """Called when runner is deregistered externally (e.g., from dashboard)."""
        logger.warning("Runner was deregistered externally - shutting down")
        self._externally_deregistered = True
        self.shutdown()

    def stop(self) -> None:
        """Stop all background threads and deregister from Agent Coordinator."""
        logger.info("Stopping runner...")

        if self.poller:
            self.poller.stop()
        if self.supervisor:
            self.supervisor.stop()
        if self.heartbeat:
            self.heartbeat.stop()

        # Stop the proxy server
        self.proxy.stop()

        # Deregister from Agent Coordinator (only if not already deregistered externally)
        if self.runner_id and not self._externally_deregistered:
            self.api_client.deregister(self.runner_id)

        self.api_client.close()
        logger.info("Runner stopped")

    def wait_for_shutdown(self) -> None:
        """Wait for shutdown signal."""
        self._shutdown_event.wait()

    def shutdown(self) -> None:
        """Signal shutdown."""
        self._shutdown_event.set()


@app.command()
def main(
    coordinator_url: str = typer.Option(
        None,
        "--coordinator-url",
        "-c",
        help="Agent Coordinator URL (env: AGENT_ORCHESTRATOR_API_URL)",
    ),
    executor: str = typer.Option(
        None,
        "--executor",
        "-x",
        help="Executor name (e.g., 'claude-code', 'test-executor')",
    ),
    executor_path: str = typer.Option(
        None,
        "--executor-path",
        "-e",
        help="Full executor script path (env: AGENT_EXECUTOR_PATH)",
    ),
    executor_list: bool = typer.Option(
        False,
        "--executor-list",
        "-l",
        help="List available executors and exit",
    ),
    project_dir: str = typer.Option(
        None,
        "--project-dir",
        "-p",
        help="Default project directory (env: PROJECT_DIR)",
    ),
    tags: str = typer.Option(
        None,
        "--tags",
        "-t",
        help="Comma-separated capability tags (env: RUNNER_TAGS). E.g., 'python,docker,nodejs'",
    ),
    verbose: bool = typer.Option(
        False,
        "--verbose",
        "-v",
        help="Enable verbose logging",
    ),
):
    """
    Agent Runner - Execute agent runs from Agent Coordinator.

    Polls Agent Coordinator for agent runs and spawns executor subprocesses to handle them.
    Supports concurrent agent run execution.
    """
    # Handle --executor-list
    if executor_list:
        executors = list_executors()
        if executors:
            print("Available executors:")
            for name in executors:
                print(f"  {name}")
        else:
            print("No executors found in executors/ directory")
        raise typer.Exit(0)

    # Validate mutual exclusivity of --executor and --executor-path
    if executor and executor_path:
        logger.error("Cannot use both --executor and --executor-path")
        raise typer.Exit(1)

    # Load config
    config = RunnerConfig.from_env()

    # Override with CLI args
    if coordinator_url:
        config.agent_coordinator_url = coordinator_url
    if project_dir:
        config.project_dir = project_dir
    if tags:
        config.tags = [tag.strip() for tag in tags.split(",") if tag.strip()]

    # Set executor path via env var (executor.py reads from env)
    if executor:
        # Resolve name to full path
        try:
            resolved_path = resolve_executor_name(executor)
            os.environ["AGENT_EXECUTOR_PATH"] = resolved_path
        except RuntimeError as e:
            logger.error(str(e))
            raise typer.Exit(1)
    elif executor_path:
        os.environ["AGENT_EXECUTOR_PATH"] = executor_path

    # Set log level
    if verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Create runner
    runner = Runner(config)

    # Setup signal handlers
    def handle_signal(signum, frame):
        logger.info(f"Received signal {signum}")
        runner.shutdown()

    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    try:
        # Register and start
        runner.register()
        runner.start()

        # Wait for shutdown
        runner.wait_for_shutdown()

    except DuplicateRunnerError as e:
        logger.error("=" * 60)
        logger.error("DUPLICATE RUNNER ERROR")
        logger.error("=" * 60)
        logger.error(f"A runner with this identity is already online:")
        logger.error(f"  Runner ID:     {e.runner_id}")
        logger.error(f"  Hostname:      {e.hostname}")
        logger.error(f"  Project Dir:   {e.project_dir}")
        logger.error(f"  Executor Type: {e.executor_type}")
        logger.error("")
        logger.error("Each unique combination of (hostname, project_dir, executor_type)")
        logger.error("can only have one active runner at a time.")
        logger.error("")
        logger.error("Options:")
        logger.error("  1. Use a different --project-dir for the second runner")
        logger.error("  2. Stop the existing runner first")
        logger.error("  3. Deregister the existing runner from the dashboard")
        logger.error("=" * 60)
        sys.exit(1)
    except KeyboardInterrupt:
        logger.info("Interrupted")
    except Exception as e:
        logger.error(f"Error: {e}")
        sys.exit(1)
    finally:
        runner.stop()


if __name__ == "__main__":
    app()
