#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "claude-agent-sdk",
#     "typer",
#     "httpx",
# ]
# ///
"""
Unified Claude SDK executor for Agent Orchestrator.

This command executes a Claude agent session (start or resume) based on a JSON
payload received via stdin. It replaces the separate ao-start and ao-resume
commands with a single unified entrypoint.

Usage:
    echo '<json>' | uv run ao-claude-code-exec
    uv run ao-claude-code-exec < payload.json
    uv run ao-claude-code-exec --help
    uv run ao-claude-code-exec --schema

Configuration:
    AGENT_SESSION_ID: Coordinator-generated session ID for MCP headers (ADR-010)
    AGENT_ORCHESTRATOR_API_URL: API base URL (default: http://127.0.0.1:8765)
    AGENT_ORCHESTRATOR_ENABLE_LOGGING: Enable debug logging
"""

import json
import sys
from pathlib import Path

# Configure UTF-8 encoding for Windows (CP1252 default can't handle emojis)
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8', errors='replace')
    sys.stderr.reconfigure(encoding='utf-8', errors='replace')

# Add runner lib to path for shared invocation module
# This allows all executor types (claude-code, openai, etc.) to share the schema
runner_lib = Path(__file__).parent.parent.parent / "lib"
sys.path.insert(0, str(runner_lib))

# Add local lib to path for executor-specific modules
sys.path.insert(0, str(Path(__file__).parent / "lib"))

import typer

from invocation import ExecutorInvocation, SUPPORTED_VERSIONS, INVOCATION_SCHEMA

app = typer.Typer(add_completion=False)


HELP_TEXT = """
ao-claude-code-exec - Unified Claude SDK executor for Agent Orchestrator

USAGE:
    <json-payload> | uv run ao-claude-code-exec
    uv run ao-claude-code-exec < payload.json
    uv run ao-claude-code-exec --help | --version | --schema

DESCRIPTION:
    Executes a Claude agent session (start or resume) based on a JSON
    payload received via stdin. This script is invoked by agent-runner,
    not directly by users.

JSON PAYLOAD FORMAT (Schema 2.0):
    {
      "schema_version": "2.0",       // Required: schema version
      "mode": "start" | "resume",    // Required: execution mode
      "session_id": "<string>",      // Required: coordinator-generated ID (ADR-010)
      "prompt": "<string>",          // Required: user input
      "project_dir": "<path>",       // Optional: working dir (start only)
      "agent_blueprint": {           // Optional: resolved blueprint from Runner
        "name": "<string>",
        "system_prompt": "<string>",
        "mcp_servers": { ... }
      },
      "metadata": { ... }            // Optional: extensible metadata
    }

EXAMPLES:
    # Start with schema 2.0 (agent_blueprint provided by Runner)
    echo '{"schema_version":"2.0","mode":"start","session_id":"ses_abc123","prompt":"Hello","agent_blueprint":{"name":"my-agent"}}' | uv run ao-claude-code-exec

    # Resume an existing session
    echo '{"schema_version":"2.0","mode":"resume","session_id":"ses_abc123","prompt":"Continue"}' | uv run ao-claude-code-exec

EXIT CODES:
    0    Success
    1    Error (invalid input, session error, SDK error)

ENVIRONMENT:
    AGENT_SESSION_ID                    Coordinator-generated session ID (ADR-010)
    AGENT_ORCHESTRATOR_API_URL          Coordinator API (default: http://127.0.0.1:8765)
    AGENT_ORCHESTRATOR_ENABLE_LOGGING   Enable debug logging

SCHEMA VERSION:
    Current: 2.0
    Schema 2.0: Runner resolves blueprint and passes agent_blueprint to executor.
""".strip()


def print_help():
    """Print usage help."""
    print(HELP_TEXT)


@app.command()
def main(
    version: bool = typer.Option(False, "--version", "-v", help="Show version"),
    schema: bool = typer.Option(False, "--schema", help="Print JSON schema"),
    show_help: bool = typer.Option(False, "--help", "-h", help="Show help", is_eager=True),
):
    """Execute a Claude agent session from stdin JSON."""
    from utils import error_exit, debug_log

    if show_help:
        print_help()
        raise typer.Exit(0)

    if version:
        print(f"ao-claude-code-exec schema versions: {', '.join(sorted(SUPPORTED_VERSIONS))}")
        raise typer.Exit(0)

    if schema:
        print(json.dumps(INVOCATION_SCHEMA, indent=2))
        raise typer.Exit(0)

    # DEBUG LOGGING - Command entry
    debug_log("COMMAND - ao-claude-code-exec", {
        "cwd": str(Path.cwd()),
        "argv": sys.argv,
    })

    # Parse stdin
    try:
        invocation = ExecutorInvocation.from_stdin()
        invocation.log_summary()
    except ValueError as e:
        error_exit(str(e))
    except Exception as e:
        error_exit(f"Unexpected error parsing input: {e}")

    # DEBUG LOGGING - Parsed invocation
    debug_log("COMMAND - ao-claude-code-exec parsed", {
        "mode": invocation.mode,
        "session_id": invocation.session_id,
        "has_agent_blueprint": invocation.agent_blueprint is not None,
        "project_dir": invocation.project_dir or "None",
        "prompt_length": len(invocation.prompt),
    })

    # Route by mode
    try:
        if invocation.mode == "start":
            run_start(invocation)
        else:
            run_resume(invocation)
    except ValueError as e:
        error_exit(str(e))
    except FileNotFoundError as e:
        error_exit(str(e))
    except ImportError as e:
        error_exit(str(e))
    except Exception as e:
        error_exit(f"Unexpected error: {e}")


def run_start(inv: ExecutorInvocation):
    """
    Start a new session.

    Session is already created in coordinator with status='pending' (ADR-010).
    Executor binds to session after Claude SDK starts.

    Schema 2.0: Uses agent_blueprint directly (Runner handles fetching/resolution).
    """
    from executor_config import load_config
    from claude_client import run_session_sync
    from utils import debug_log

    # 1. Load configuration
    config = load_config(
        cli_project_dir=inv.project_dir,
    )

    # 2. Get agent config from blueprint (Runner provides resolved blueprint)
    final_prompt = inv.prompt
    mcp_servers = None
    agent_name = None

    if inv.agent_blueprint:
        # Schema 2.0: Use resolved blueprint directly (no API call needed)
        agent_name = inv.agent_blueprint.get("name")
        system_prompt = inv.agent_blueprint.get("system_prompt")
        mcp_servers = inv.agent_blueprint.get("mcp_servers")

        if system_prompt:
            final_prompt = f"{system_prompt}\n\n---\n\n{inv.prompt}"

        debug_log("ao-claude-code-exec using agent_blueprint", {
            "agent_name": agent_name or "unnamed",
            "has_system_prompt": system_prompt is not None,
            "has_mcp_servers": mcp_servers is not None,
        })

    # DEBUG LOGGING
    debug_log("ao-claude-code-exec run_start", {
        "session_id": inv.session_id,
        "project_dir": str(config.project_dir),
        "agent_name": agent_name or "None",
        "has_mcp_servers": mcp_servers is not None,
        "final_prompt_length": len(final_prompt),
        "schema_version": inv.schema_version,
    })

    # 3. Run Claude session (binds to coordinator session automatically)
    # Auth is handled by Agent Coordinator Proxy
    executor_session_id, result = run_session_sync(
        prompt=final_prompt,
        project_dir=config.project_dir,
        session_id=inv.session_id,
        mcp_servers=mcp_servers,
        api_url=config.api_url,
        agent_name=agent_name,
    )

    # Print result to stdout
    print(result)


def run_resume(inv: ExecutorInvocation):
    """
    Resume an existing session.

    Fetches session affinity to get executor_session_id for Claude SDK resume.

    Schema 2.0: Uses agent_blueprint for MCP servers (Runner handles fetching/resolution).
    """
    from executor_config import get_api_url
    from session_client import SessionClient, SessionClientError
    from claude_client import run_session_sync
    from utils import debug_log

    # 1. Get API URL (auth handled by Agent Coordinator Proxy)
    api_url = get_api_url()

    # 2. Get session and affinity data
    try:
        client = SessionClient(api_url)
        session_data = client.get_session(inv.session_id)
    except SessionClientError as e:
        raise ValueError(f"Failed to connect to session manager: {e}")

    if not session_data:
        raise ValueError(
            f"Session '{inv.session_id}' does not exist. "
            "Use mode='start' to create it"
        )

    # Extract session data
    executor_session_id = session_data.get("executor_session_id")
    session_project_dir = Path(session_data.get("project_dir", str(Path.cwd())))
    session_agent = session_data.get("agent_name")

    # Validate executor_session_id exists (needed for Claude SDK resume)
    if not executor_session_id:
        raise ValueError(
            f"Session '{inv.session_id}' has no executor_session_id. "
            "Cannot resume - session may not have started successfully"
        )

    # 3. Get MCP servers from blueprint (Runner provides resolved blueprint)
    # NOTE: Do NOT prepend system prompt for resume (only for new sessions)
    mcp_servers = None
    agent_name = session_agent

    if inv.agent_blueprint:
        # Schema 2.0: Use resolved blueprint directly (no API call needed)
        mcp_servers = inv.agent_blueprint.get("mcp_servers")
        # Use agent name from blueprint if available, otherwise from session
        agent_name = inv.agent_blueprint.get("name") or session_agent

        debug_log("ao-claude-code-exec resume using agent_blueprint", {
            "agent_name": agent_name or "None",
            "has_mcp_servers": mcp_servers is not None,
        })

    # DEBUG LOGGING
    debug_log("ao-claude-code-exec run_resume", {
        "session_id": inv.session_id,
        "executor_session_id": executor_session_id,
        "project_dir": str(session_project_dir),
        "agent_name": agent_name or "None",
        "has_mcp_servers": mcp_servers is not None,
        "schema_version": inv.schema_version,
    })

    # 4. Run Claude session with resume (uses executor_session_id for SDK resume)
    # Auth is handled by Agent Coordinator Proxy
    new_executor_session_id, result = run_session_sync(
        prompt=inv.prompt,  # No system prompt prepended!
        project_dir=session_project_dir,
        session_id=inv.session_id,
        mcp_servers=mcp_servers,
        resume_executor_session_id=executor_session_id,
        api_url=api_url,
        agent_name=agent_name,
    )

    # Print result to stdout
    print(result)


if __name__ == "__main__":
    app()
