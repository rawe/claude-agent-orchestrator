#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "httpx",
# ]
# ///
"""
Test Executor - Simple dummy executor for testing.

Echoes prompts back as responses. Does not use any AI SDK.
Stores session data in local .test-executor-data/ folder.

Uses session_id (coordinator-generated) per ADR-010.

Usage:
    echo '{"schema_version":"1.0","mode":"start","session_id":"ses_abc123","prompt":"Hello"}' | uv run ao-test-exec
"""

import json
import sys
import uuid
from pathlib import Path
from datetime import datetime, UTC

# Configure UTF-8 encoding for Windows (CP1252 default can't handle emojis)
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8', errors='replace')
    sys.stderr.reconfigure(encoding='utf-8', errors='replace')

# Add runner lib to path for shared modules
runner_lib = Path(__file__).parent.parent.parent / "lib"
sys.path.insert(0, str(runner_lib))

from invocation import ExecutorInvocation
from session_client import SessionClient, SessionClientError
from executor_config import get_api_url

# Storage directory (git-ignored)
DATA_DIR = Path(__file__).parent / ".test-executor-data"


def get_storage_path(session_id: str) -> Path:
    """Get path to session data file."""
    DATA_DIR.mkdir(exist_ok=True)
    return DATA_DIR / f"{session_id}.json"


def load_session_data(session_id: str) -> dict | None:
    """Load session data from file."""
    path = get_storage_path(session_id)
    if path.exists():
        return json.loads(path.read_text())
    return None


def save_session_data(session_id: str, data: dict) -> None:
    """Save session data to file."""
    path = get_storage_path(session_id)
    path.write_text(json.dumps(data, indent=2))


def generate_executor_session_id() -> str:
    """Generate an executor session ID (simulates Claude SDK session UUID)."""
    return str(uuid.uuid4())


def generate_response(prompt: str) -> str:
    """Generate a simple echo response."""
    return f"[TEST-EXECUTOR] Received: {prompt}"


def run_start(inv: ExecutorInvocation) -> None:
    """Start a new session."""
    api_url = get_api_url()
    client = SessionClient(api_url)

    session_id = inv.session_id

    # Check if session already exists locally
    existing = load_session_data(session_id)
    if existing:
        print(f"Error: Session '{session_id}' already exists locally", file=sys.stderr)
        sys.exit(1)

    # Generate executor session ID (simulates what Claude SDK would generate)
    executor_session_id = generate_executor_session_id()

    # Bind this executor to the session (per ADR-010)
    try:
        import socket
        hostname = socket.gethostname()
        client.bind_session_executor(
            session_id=session_id,
            executor_session_id=executor_session_id,
            hostname=hostname,
            executor_type="test-executor",
        )
    except SessionClientError as e:
        print(f"Warning: Could not bind session executor: {e}", file=sys.stderr)

    # Store session data locally
    session_data = {
        "session_id": session_id,
        "executor_session_id": executor_session_id,
        "created_at": datetime.now(UTC).isoformat(),
        "messages": [],
    }

    # Add user message
    session_data["messages"].append({
        "role": "user",
        "content": inv.prompt,
        "timestamp": datetime.now(UTC).isoformat(),
    })

    # Send user message event
    try:
        client.add_event(session_id, {
            "event_type": "message",
            "session_id": session_id,
            "timestamp": datetime.now(UTC).isoformat(),
            "role": "user",
            "content": [{"type": "text", "text": inv.prompt}],
        })
    except SessionClientError:
        pass

    # Generate response
    response = generate_response(inv.prompt)

    # Add assistant message
    session_data["messages"].append({
        "role": "assistant",
        "content": response,
        "timestamp": datetime.now(UTC).isoformat(),
    })

    # Save session data
    save_session_data(session_id, session_data)

    # Send assistant message event
    try:
        client.add_event(session_id, {
            "event_type": "message",
            "session_id": session_id,
            "timestamp": datetime.now(UTC).isoformat(),
            "role": "assistant",
            "content": [{"type": "text", "text": response}],
        })
    except SessionClientError:
        pass

    # Send session_stop event
    try:
        client.add_event(session_id, {
            "event_type": "session_stop",
            "session_id": session_id,
            "timestamp": datetime.now(UTC).isoformat(),
            "exit_code": 0,
            "reason": "completed",
        })
    except SessionClientError:
        pass

    # Print response to stdout
    print(response)


def run_resume(inv: ExecutorInvocation) -> None:
    """Resume an existing session."""
    api_url = get_api_url()
    client = SessionClient(api_url)

    session_id = inv.session_id

    # Load existing session
    session_data = load_session_data(session_id)
    if not session_data:
        print(f"Error: Session '{session_id}' not found locally", file=sys.stderr)
        sys.exit(1)

    # Send session_start event (resume)
    try:
        client.add_event(session_id, {
            "event_type": "session_start",
            "session_id": session_id,
            "timestamp": datetime.now(UTC).isoformat(),
        })
    except SessionClientError:
        pass

    # Add user message
    session_data["messages"].append({
        "role": "user",
        "content": inv.prompt,
        "timestamp": datetime.now(UTC).isoformat(),
    })

    # Send user message event
    try:
        client.add_event(session_id, {
            "event_type": "message",
            "session_id": session_id,
            "timestamp": datetime.now(UTC).isoformat(),
            "role": "user",
            "content": [{"type": "text", "text": inv.prompt}],
        })
    except SessionClientError:
        pass

    # Generate response
    response = generate_response(inv.prompt)

    # Add assistant message
    session_data["messages"].append({
        "role": "assistant",
        "content": response,
        "timestamp": datetime.now(UTC).isoformat(),
    })

    # Update last_resumed_at
    session_data["last_resumed_at"] = datetime.now(UTC).isoformat()

    # Save session data
    save_session_data(session_id, session_data)

    # Send assistant message event
    try:
        client.add_event(session_id, {
            "event_type": "message",
            "session_id": session_id,
            "timestamp": datetime.now(UTC).isoformat(),
            "role": "assistant",
            "content": [{"type": "text", "text": response}],
        })
    except SessionClientError:
        pass

    # Send session_stop event
    try:
        client.add_event(session_id, {
            "event_type": "session_stop",
            "session_id": session_id,
            "timestamp": datetime.now(UTC).isoformat(),
            "exit_code": 0,
            "reason": "completed",
        })
    except SessionClientError:
        pass

    # Print response to stdout
    print(response)


def main() -> None:
    """Main entry point."""
    # Parse invocation from stdin
    try:
        inv = ExecutorInvocation.from_stdin()
    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    # Route by mode
    if inv.mode == "start":
        run_start(inv)
    else:
        run_resume(inv)


if __name__ == "__main__":
    main()
