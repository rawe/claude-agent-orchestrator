/**
 * Element Selector Module for Context Store Browser Extension
 *
 * Provides visual element selection with overlay highlighting and
 * stable CSS selector generation.
 *
 * NESTED ELEMENT STRATEGY:
 * ========================
 * When the user hovers over the page, we highlight the deepest element
 * under the cursor (event.target). This is the simplest and most intuitive
 * approach - what you point at is what you get.
 *
 * Future enhancements could include:
 * - Scroll wheel to walk up/down the DOM tree
 * - Keyboard modifiers (Shift to select parent)
 * - Breadcrumb UI showing ancestor elements
 * - Minimum size threshold to skip tiny elements
 *
 * For now, if users want a parent container, they can hover over an area
 * of that container that doesn't have nested children (like padding areas).
 */

(function() {
  'use strict';

  // State
  let isSelectionMode = false;
  let currentHighlight = null;
  let overlayElements = null;
  let selectedElement = null;
  let selectionCallback = null;

  /**
   * CSS Selector Generator
   *
   * Strategy: Generate the most STABLE selector possible.
   * Priority order:
   * 1. ID (if unique and not auto-generated looking)
   * 2. data-testid, data-cy, data-test attributes (testing attributes)
   * 3. Unique semantic attributes (name, role, aria-label)
   * 4. Unique class combination
   * 5. Tag + classes + nth-child as fallback
   */
  const SelectorGenerator = {
    /**
     * Generate a stable CSS selector for an element
     * @param {HTMLElement} element
     * @returns {string} CSS selector
     */
    generate(element) {
      if (!element || element === document.body || element === document.documentElement) {
        return element?.tagName?.toLowerCase() || 'body';
      }

      // Try ID first (if it looks stable, not auto-generated)
      const idSelector = this.tryIdSelector(element);
      if (idSelector) return idSelector;

      // Try test/data attributes
      const dataSelector = this.tryDataAttributes(element);
      if (dataSelector) return dataSelector;

      // Try semantic attributes
      const semanticSelector = this.trySemanticAttributes(element);
      if (semanticSelector) return semanticSelector;

      // Try unique class combination
      const classSelector = this.tryClassSelector(element);
      if (classSelector) return classSelector;

      // Fallback: build path from nearest identifiable ancestor
      return this.buildPathSelector(element);
    },

    /**
     * Check if an ID looks auto-generated
     */
    isAutoGeneratedId(id) {
      if (!id) return true;
      // Common patterns for auto-generated IDs
      const autoPatterns = [
        /^[a-f0-9]{8,}$/i,           // hex strings
        /^[a-z]+[-_]?[0-9]+$/i,       // prefix + number (like "el-123")
        /^:r[0-9]+:$/,                // React-generated
        /^ember[0-9]+$/,              // Ember-generated
        /^ng-[a-z]+-[0-9]+$/,         // Angular-generated
        /^[0-9]+$/,                   // Pure numbers
        /^yui_/,                      // YUI-generated
        /^ext-gen/,                   // ExtJS-generated
      ];
      return autoPatterns.some(pattern => pattern.test(id));
    },

    /**
     * Try to create a selector using element ID
     */
    tryIdSelector(element) {
      const id = element.id;
      if (!id || this.isAutoGeneratedId(id)) return null;

      const selector = `#${CSS.escape(id)}`;
      // Verify it's unique
      if (document.querySelectorAll(selector).length === 1) {
        return selector;
      }
      return null;
    },

    /**
     * Try data-* testing attributes (most stable for testing)
     */
    tryDataAttributes(element) {
      const testAttributes = [
        'data-testid',
        'data-test-id',
        'data-test',
        'data-cy',
        'data-qa',
        'data-automation-id',
        'data-component',
        'data-id'
      ];

      for (const attr of testAttributes) {
        const value = element.getAttribute(attr);
        if (value) {
          const selector = `[${attr}="${CSS.escape(value)}"]`;
          if (document.querySelectorAll(selector).length === 1) {
            return selector;
          }
        }
      }
      return null;
    },

    /**
     * Try semantic attributes that are likely stable
     */
    trySemanticAttributes(element) {
      const tag = element.tagName.toLowerCase();

      // Form elements with name
      if (element.name && ['input', 'select', 'textarea', 'button'].includes(tag)) {
        const selector = `${tag}[name="${CSS.escape(element.name)}"]`;
        if (document.querySelectorAll(selector).length === 1) {
          return selector;
        }
      }

      // Elements with role
      const role = element.getAttribute('role');
      if (role) {
        const selector = `[role="${CSS.escape(role)}"]`;
        if (document.querySelectorAll(selector).length === 1) {
          return selector;
        }
      }

      // Aria-label (often unique for interactive elements)
      const ariaLabel = element.getAttribute('aria-label');
      if (ariaLabel && ariaLabel.length < 50) {
        const selector = `[aria-label="${CSS.escape(ariaLabel)}"]`;
        if (document.querySelectorAll(selector).length === 1) {
          return selector;
        }
      }

      // Links with unique href
      if (tag === 'a' && element.href) {
        const href = element.getAttribute('href');
        if (href && !href.startsWith('#') && !href.startsWith('javascript:')) {
          const selector = `a[href="${CSS.escape(href)}"]`;
          if (document.querySelectorAll(selector).length === 1) {
            return selector;
          }
        }
      }

      return null;
    },

    /**
     * Try to find a unique class combination
     */
    tryClassSelector(element) {
      const classes = Array.from(element.classList)
        .filter(cls => !this.isAutoGeneratedClass(cls));

      if (classes.length === 0) return null;

      const tag = element.tagName.toLowerCase();

      // Try single classes first (most readable)
      for (const cls of classes) {
        const selector = `.${CSS.escape(cls)}`;
        if (document.querySelectorAll(selector).length === 1) {
          return selector;
        }
      }

      // Try tag + single class
      for (const cls of classes) {
        const selector = `${tag}.${CSS.escape(cls)}`;
        if (document.querySelectorAll(selector).length === 1) {
          return selector;
        }
      }

      // Try combinations of 2-3 classes
      if (classes.length >= 2) {
        for (let i = 0; i < classes.length; i++) {
          for (let j = i + 1; j < classes.length; j++) {
            const selector = `.${CSS.escape(classes[i])}.${CSS.escape(classes[j])}`;
            if (document.querySelectorAll(selector).length === 1) {
              return selector;
            }
          }
        }
      }

      return null;
    },

    /**
     * Check if a class looks auto-generated
     */
    isAutoGeneratedClass(cls) {
      const autoPatterns = [
        /^[a-z]{1,3}[0-9]+$/i,        // short prefix + numbers
        /^_[a-z0-9]+$/i,              // underscore prefix
        /^css-[a-z0-9]+$/i,           // CSS-in-JS (emotion)
        /^sc-[a-z]+$/i,               // styled-components
        /^jsx-[0-9]+$/,               // Next.js/styled-jsx
        /^svelte-[a-z0-9]+$/,         // Svelte
        /^[a-z]+__[a-z]+--[a-z]+$/i,  // BEM with modifiers often generated
      ];
      return autoPatterns.some(pattern => pattern.test(cls));
    },

    /**
     * Build a path-based selector from nearest identifiable ancestor
     */
    buildPathSelector(element) {
      const path = [];
      let current = element;

      while (current && current !== document.body && current !== document.documentElement) {
        const segment = this.getPathSegment(current);
        path.unshift(segment);

        // If we hit an element with ID, we can stop
        if (current.id && !this.isAutoGeneratedId(current.id)) {
          path[0] = `#${CSS.escape(current.id)}`;
          break;
        }

        // Also stop if we have a data-testid ancestor
        const testId = current.getAttribute('data-testid') || current.getAttribute('data-test-id');
        if (testId) {
          path[0] = `[data-testid="${CSS.escape(testId)}"]`;
          break;
        }

        current = current.parentElement;

        // Safety limit
        if (path.length > 5) {
          // Keep last 5 segments, that should be enough
          break;
        }
      }

      return path.join(' > ');
    },

    /**
     * Get a path segment for an element (tag + classes + nth-child if needed)
     */
    getPathSegment(element) {
      const tag = element.tagName.toLowerCase();
      const classes = Array.from(element.classList)
        .filter(cls => !this.isAutoGeneratedClass(cls))
        .slice(0, 2); // Max 2 classes for readability

      let segment = tag;
      if (classes.length > 0) {
        segment += '.' + classes.map(c => CSS.escape(c)).join('.');
      }

      // Check if this is unique among siblings
      const parent = element.parentElement;
      if (parent) {
        const siblings = Array.from(parent.children).filter(
          child => {
            if (child.tagName !== element.tagName) return false;
            if (classes.length === 0) return true;
            return classes.some(cls => child.classList.contains(cls));
          }
        );

        if (siblings.length > 1) {
          const index = siblings.indexOf(element) + 1;
          segment += `:nth-child(${index})`;
        }
      }

      return segment;
    },

    /**
     * Validate that a selector matches exactly one element
     */
    validate(selector) {
      try {
        const matches = document.querySelectorAll(selector);
        return matches.length === 1;
      } catch {
        return false;
      }
    }
  };

  /**
   * Create the overlay elements for highlighting
   */
  function createOverlayElements() {
    // Container for all overlay elements
    const container = document.createElement('div');
    container.id = 'context-store-selector-overlay';
    container.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2147483647;
    `;

    // Highlight box
    const highlight = document.createElement('div');
    highlight.id = 'context-store-highlight';
    highlight.style.cssText = `
      position: fixed;
      border: 2px solid #6366f1;
      background: rgba(99, 102, 241, 0.1);
      pointer-events: none;
      transition: all 0.05s ease-out;
      display: none;
      box-sizing: border-box;
    `;

    // Label showing element info
    const label = document.createElement('div');
    label.id = 'context-store-label';
    label.style.cssText = `
      position: fixed;
      background: #6366f1;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace;
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 4px;
      pointer-events: none;
      white-space: nowrap;
      max-width: 400px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    `;

    // Instructions tooltip
    const instructions = document.createElement('div');
    instructions.id = 'context-store-instructions';
    instructions.style.cssText = `
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: #1f2937;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 13px;
      padding: 10px 16px;
      border-radius: 8px;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 2147483647;
    `;
    instructions.textContent = 'Click an element to select it â€¢ Press ESC to cancel';

    container.appendChild(highlight);
    container.appendChild(label);
    container.appendChild(instructions);

    return { container, highlight, label, instructions };
  }

  /**
   * Get element info string for label
   */
  function getElementLabel(element) {
    const tag = element.tagName.toLowerCase();
    const id = element.id ? `#${element.id}` : '';
    const classes = Array.from(element.classList)
      .filter(cls => !SelectorGenerator.isAutoGeneratedClass(cls))
      .slice(0, 3)
      .map(cls => `.${cls}`)
      .join('');

    let label = tag + id + classes;

    // Add text content hint for interactive elements
    if (['button', 'a', 'label'].includes(tag)) {
      const text = element.textContent?.trim().substring(0, 20);
      if (text) {
        label += ` "${text}${element.textContent.trim().length > 20 ? '...' : ''}"`;
      }
    }

    return label;
  }

  /**
   * Position the highlight and label over an element
   */
  function positionOverlay(element) {
    if (!overlayElements || !element) return;

    const rect = element.getBoundingClientRect();
    const { highlight, label } = overlayElements;

    // Position highlight
    highlight.style.display = 'block';
    highlight.style.top = `${rect.top}px`;
    highlight.style.left = `${rect.left}px`;
    highlight.style.width = `${rect.width}px`;
    highlight.style.height = `${rect.height}px`;

    // Position label (above or below element depending on space)
    label.style.display = 'block';
    label.textContent = getElementLabel(element);

    const labelRect = label.getBoundingClientRect();
    const spaceAbove = rect.top;
    const spaceBelow = window.innerHeight - rect.bottom;

    if (spaceAbove > 30 || spaceAbove > spaceBelow) {
      // Position above
      label.style.top = `${Math.max(4, rect.top - 28)}px`;
    } else {
      // Position below
      label.style.top = `${Math.min(window.innerHeight - 28, rect.bottom + 4)}px`;
    }

    // Horizontal positioning
    let labelLeft = rect.left;
    if (labelLeft + 300 > window.innerWidth) {
      labelLeft = window.innerWidth - 300;
    }
    label.style.left = `${Math.max(4, labelLeft)}px`;
  }

  /**
   * Hide the overlay
   */
  function hideOverlay() {
    if (!overlayElements) return;
    overlayElements.highlight.style.display = 'none';
    overlayElements.label.style.display = 'none';
  }

  /**
   * Mouse move handler during selection mode
   */
  function handleMouseMove(event) {
    if (!isSelectionMode) return;

    const element = event.target;

    // Skip our own overlay elements
    if (element.closest('#context-store-selector-overlay')) {
      return;
    }

    currentHighlight = element;
    positionOverlay(element);
  }

  /**
   * Click handler during selection mode
   */
  function handleClick(event) {
    if (!isSelectionMode) return;

    // Skip our own overlay elements
    if (event.target.closest('#context-store-selector-overlay')) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();

    selectedElement = currentHighlight;

    if (selectedElement && selectionCallback) {
      const selector = SelectorGenerator.generate(selectedElement);
      const result = {
        selector: selector,
        tagName: selectedElement.tagName.toLowerCase(),
        id: selectedElement.id || null,
        classes: Array.from(selectedElement.classList),
        outerHTML: selectedElement.outerHTML,
        innerHTML: selectedElement.innerHTML,
        textContent: selectedElement.textContent?.trim().substring(0, 200),
        rect: selectedElement.getBoundingClientRect().toJSON(),
        selectorValid: SelectorGenerator.validate(selector)
      };

      exitSelectionMode();
      selectionCallback(result);
    }
  }

  /**
   * Keyboard handler for ESC to cancel
   */
  function handleKeyDown(event) {
    if (!isSelectionMode) return;

    if (event.key === 'Escape') {
      event.preventDefault();
      exitSelectionMode();
      if (selectionCallback) {
        selectionCallback(null); // Cancelled
      }
    }
  }

  /**
   * Enter element selection mode
   * @param {Function} callback - Called with selection result or null if cancelled
   */
  function enterSelectionMode(callback) {
    if (isSelectionMode) return;

    isSelectionMode = true;
    selectionCallback = callback;
    selectedElement = null;
    currentHighlight = null;

    // Create and append overlay
    overlayElements = createOverlayElements();
    document.body.appendChild(overlayElements.container);

    // Change cursor
    document.body.style.cursor = 'crosshair';

    // Add event listeners
    document.addEventListener('mousemove', handleMouseMove, true);
    document.addEventListener('click', handleClick, true);
    document.addEventListener('keydown', handleKeyDown, true);

    console.log('[Bug Spotter] Selection mode activated');
  }

  /**
   * Exit element selection mode
   */
  function exitSelectionMode() {
    if (!isSelectionMode) return;

    isSelectionMode = false;

    // Remove overlay
    if (overlayElements) {
      overlayElements.container.remove();
      overlayElements = null;
    }

    // Reset cursor
    document.body.style.cursor = '';

    // Remove event listeners
    document.removeEventListener('mousemove', handleMouseMove, true);
    document.removeEventListener('click', handleClick, true);
    document.removeEventListener('keydown', handleKeyDown, true);

    currentHighlight = null;

    console.log('[Bug Spotter] Selection mode deactivated');
  }

  /**
   * Check if currently in selection mode
   */
  function isInSelectionMode() {
    return isSelectionMode;
  }

  // Expose API to window (for direct page access if needed)
  window.ContextStoreSelector = {
    enterSelectionMode,
    exitSelectionMode,
    isInSelectionMode,
    generateSelector: (element) => SelectorGenerator.generate(element),
    validateSelector: (selector) => SelectorGenerator.validate(selector)
  };

  // Listen for messages from content script to start selection
  window.addEventListener('message', (event) => {
    if (event.source !== window) return;

    if (event.data && event.data.type === 'CONTEXT_STORE_START_SELECTION') {
      console.log('[Bug Spotter] Received start selection message');
      enterSelectionMode((result) => {
        // Send result back to content script via postMessage
        window.postMessage({
          type: 'CONTEXT_STORE_SELECTION_RESULT',
          result: result
        }, '*');
      });
    }
  });

  console.log('[Bug Spotter] Selector script initialized');

})();
