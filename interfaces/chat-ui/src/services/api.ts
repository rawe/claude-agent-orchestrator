import axios, { AxiosError } from 'axios';
import { config } from '../config';
import { fetchAccessToken, isOidcConfigured } from './auth';
import type { RunRequest, RunResponse } from '../types';

// Create axios instance
const api = axios.create({
  baseURL: config.apiUrl,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor to add auth token
api.interceptors.request.use(async (requestConfig) => {
  // Add OIDC token if configured and available
  if (isOidcConfigured()) {
    const token = await fetchAccessToken();
    if (token) {
      requestConfig.headers.Authorization = `Bearer ${token}`;
    }
  }
  // When OIDC is not configured, requests go without auth
  // (for local development with AUTH_ENABLED=false on coordinator)
  return requestConfig;
});

// Error handler with auth-specific messages
function handleError(error: unknown): never {
  if (axios.isAxiosError(error)) {
    const axiosError = error as AxiosError<{ detail?: string; message?: string }>;
    const status = axiosError.response?.status;

    // Auth-specific error messages
    if (status === 401) {
      throw new Error('Authentication required. Please log in.');
    }
    if (status === 403) {
      throw new Error('Access denied. Invalid or expired token.');
    }

    const message = axiosError.response?.data?.detail
      || axiosError.response?.data?.message
      || axiosError.message
      || 'An error occurred';
    throw new Error(message);
  }
  throw error;
}

/**
 * Chat API Service
 * See: docs/components/agent-coordinator/API.md
 */
export const chatService = {
  /**
   * Start a new chat session (POST /runs)
   * Session ID is generated by the coordinator (ADR-010)
   */
  async startSession(prompt: string): Promise<{ runId: string; sessionId: string }> {
    const request: RunRequest = {
      type: 'start_session',
      parameters: { prompt },
      agent_name: config.agentBlueprint,
    };

    try {
      const response = await api.post<RunResponse>('/runs', request);
      return {
        runId: response.data.run_id,
        sessionId: response.data.session_id,
      };
    } catch (error) {
      handleError(error);
    }
  },

  /**
   * Resume an existing session (POST /runs)
   */
  async resumeSession(sessionId: string, prompt: string): Promise<{ runId: string }> {
    const request: RunRequest = {
      type: 'resume_session',
      session_id: sessionId,
      parameters: { prompt },
    };

    try {
      const response = await api.post<RunResponse>('/runs', request);
      return {
        runId: response.data.run_id,
      };
    } catch (error) {
      handleError(error);
    }
  },

  /**
   * Stop a running session (POST /sessions/{session_id}/stop)
   */
  async stopSession(sessionId: string): Promise<void> {
    try {
      await api.post(`/sessions/${sessionId}/stop`);
    } catch (error) {
      handleError(error);
    }
  },
};
