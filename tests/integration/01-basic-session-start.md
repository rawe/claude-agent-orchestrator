# Test: Basic Session Start

Verify that starting a new session produces the correct sequence of WebSocket events.

## Prerequisites

- Database reset: `./tests/scripts/reset-db`
- Agent Coordinator running
- Agent Runner running with `-x test-executor` profile
- sse-monitor running

## Test Steps

### Step 1: Create a start_session run

```bash
curl -X POST http://localhost:8765/runs \
  -H "Content-Type: application/json" \
  -d '{
    "type": "start_session",
    "parameters": {"prompt": "Hello, this is a test message"},
    "project_dir": "."
  }'
```

Expected response:
```json
{"run_id":"run_...","session_id":"ses_...","status":"pending","message":"Run queued"}
```

Note: The `session_id` is generated by the coordinator (format: `ses_{12_hex_chars}`).

### Step 2: Wait for execution

The runner should pick up the run within a few seconds. Watch the runner terminal for:
```
[INFO] poller: Received run run_... (start_session)
[INFO] executor: Starting session ses_... with agent test-agent
```

### Step 3: Observe WebSocket events

Watch the sse-monitor output.

## Expected Events (in order)

1. **session_created** (status: pending, when run is queued)
   ```json
   {"type": "session_created", "session": {"session_id": "ses_...", "status": "pending", "agent_name": null, ...}}
   ```

2. **run_start** (when runner reports run started)
   ```json
   {"type": "event", "data": {"event_type": "run_start", "session_id": "ses_...", "timestamp": "...", ...}}
   ```
   Note: Emitted by coordinator when agent runner calls `report_run_started`.

3. **session_updated** (status: running, when executor binds)
   ```json
   {"type": "session_updated", "session": {"session_id": "ses_...", "status": "running", "executor_session_id": "<uuid>", ...}}
   ```

4. **message (user)**
   ```json
   {"type": "event", "data": {"event_type": "message", "session_id": "ses_...", "role": "user", "content": [{"type": "text", "text": "Hello, this is a test message"}], ...}}
   ```

5. **message (assistant)**
   ```json
   {"type": "event", "data": {"event_type": "message", "session_id": "ses_...", "role": "assistant", "content": [{"type": "text", "text": "<response from executor>"}], ...}}
   ```
   - With `test-executor`: `"[TEST-EXECUTOR] Received: Hello, this is a test message"`
   - With `claude-code`: Actual Claude response

6. **session_updated** (status: finished)
   ```json
   {"type": "session_updated", "session": {"session_id": "ses_...", "status": "finished", ...}}
   ```

7. **run_completed**
   ```json
   {"type": "event", "data": {"event_type": "run_completed", "session_id": "ses_...", "exit_code": 0, "reason": "completed", ...}}
   ```
   Note: Emitted by coordinator when agent runner calls `report_run_completed`.

## Verification Checklist

- [ ] All events received in correct order (session_created, run_start, session_updated:running, user message, assistant message, session_updated:finished, run_completed)
- [ ] `session_id` is consistent across all events (format: `ses_...`)
- [ ] `session_id` in response matches events
- [ ] `run_start` event received (emitted by agent runner via report_run_started)
- [ ] User message content matches the prompt sent
- [ ] Assistant message received (content depends on executor type)
- [ ] run_completed has exit_code 0 and reason "completed"
- [ ] Timestamps are sequential (each event timestamp >= previous)
- [ ] Session bound with `executor_session_id` when status changes to running

## Cleanup

The session data is stored in:
- Database: `servers/agent-coordinator/.agent-orchestrator/observability.db`
- Test executor: `servers/agent-runner/executors/test-executor/.test-executor-data/<session_id>.json`

Run `./tests/scripts/reset-db` before the next test.
