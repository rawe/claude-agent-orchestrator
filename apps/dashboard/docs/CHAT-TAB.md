# Chat Tab

The Chat tab provides a live chat interface for interacting with AI agents using the Agent Orchestration Framework.

## Architecture

```
┌─────────────────┐     REST API      ┌──────────────────────┐
│                 │ ───────────────►  │  Agent Coordinator   │
│    Chat Tab     │   /runs, /agents  │     (port 8765)      │
│                 │                   │                      │
└─────────────────┘                   └──────────────────────┘
         │                                      │
         │                                      │
         ▼                                      │
┌─────────────────┐                             │
│  ChatContext    │ ◄───────────────────────────┘
│  (App level)    │         SSE
│                 │    (/sse/sessions)
└─────────────────┘
```

## Key Files

| File | Purpose |
|------|---------|
| `src/contexts/ChatContext.tsx` | Global chat state and SSE message handling |
| `src/pages/Chat.tsx` | Chat UI component |
| `src/services/chatService.ts` | API client for Agent Coordinator |
| `src/services/api.ts` | Axios instance for API calls |
| `src/utils/constants.ts` | `AGENT_ORCHESTRATOR_API_URL` (default: `http://localhost:8765`) |

## API Usage

The Chat tab uses the **Agent Coordinator REST API** for these operations:

### 1. List Blueprints
```
GET /agents
```
Fetches available agent blueprints for the dropdown selector. A refresh button allows reloading the list.

### 2. Start Session (via Run API)
```
POST /runs
{
  "type": "start_session",
  "prompt": "user message",
  "agent_name": "web-researcher",  // optional
  "project_dir": "/path/to/project"  // optional
}
```
Creates a new run that starts an agent session. Session ID is generated by the coordinator (ADR-010).

### 3. Resume Session (via Run API)
```
POST /runs
{
  "type": "resume_session",
  "session_id": "uuid-session-id",
  "prompt": "follow-up message"
}
```
Creates a run to resume an existing session with a new prompt.

## SSE Integration

The Chat tab reuses the **existing SSE connection** from the dashboard. The SSE subscription is managed in `ChatContext` at the App level, ensuring messages are received even when navigating to other tabs.

### Event Flow

1. **Capture session_id**: Listen for `session_created` or `session_updated` events matching our `session_id`
2. **Receive response**: Listen for `event` messages where:
   - `data.event_type === 'message'`
   - `data.role === 'assistant'`
   - `data.session_id` matches our session
3. **Extract content**: Get text from `data.content[].text`

### SSE Message Types Used

```typescript
// Capture session_id
{ type: 'session_created', session: { session_id, status, parent_session_id?, ... } }
{ type: 'session_updated', session: { session_id, status, parent_session_id?, ... } }

// Receive agent response
{ type: 'event', data: {
    session_id,
    event_type: 'message',
    role: 'assistant',
    content: [{ type: 'text', text: '...' }]
  }
}

// Run start/resume (used for callback detection)
{ type: 'event', data: {
    session_id,
    event_type: 'run_start'
  }
}

// Tool execution completed
{ type: 'event', data: {
    session_id,
    event_type: 'post_tool',
    tool_name: 'ToolName',
    tool_input: {...},
    tool_output: {...}
  }
}

// Run completed
{ type: 'event', data: {
    session_id,
    event_type: 'run_completed',
    exit_code: 0
  }
}
```

## Callback Resume Feature

The Chat tab supports automatic updates when a session resumes via the callback architecture. This happens when:

1. A parent session spawns a child agent with `callback=true`
2. The parent session goes to `finished` state while waiting
3. The child session completes its work
4. The framework calls back to resume the parent session
5. The parent session continues processing

### How Callback Resume Works

```
┌─────────────────┐                    ┌─────────────────┐
│  Parent Session │                    │  Child Session  │
│   (Chat Tab)    │                    │   (Math Agent)  │
└────────┬────────┘                    └────────┬────────┘
         │                                      │
         │ 1. User sends prompt                 │
         │    "calculate 1+5 with callback"     │
         ▼                                      │
    ┌─────────┐                                 │
    │ running │                                 │
    └────┬────┘                                 │
         │ 2. Spawns child with callback=true   │
         │ ─────────────────────────────────────►
         ▼                                      ▼
    ┌──────────┐                          ┌─────────┐
    │ finished │                          │ running │
    └────┬─────┘                          └────┬────┘
         │                                     │
         │ 3. Chat shows "Agent is finished"   │ 4. Child calculates
         │                                     │
         │                                     ▼
         │                               ┌──────────┐
         │                               │ finished │
         │                               └────┬─────┘
         │                                    │
         │ ◄──────────────────────────────────┘
         │ 5. Callback resumes parent
         ▼
    ┌─────────┐
    │ running │  ◄── run_start event triggers refresh
    └────┬────┘
         │
         │ 6. Chat fetches updated events
         │    Shows user message + pending indicator
         │
         ▼
    ┌──────────┐
    │ finished │  ◄── Assistant response displayed
    └──────────┘
```

### Implementation Details

The callback resume detection is implemented in `ChatContext.tsx`:

1. **Session Matching**: Sessions are matched by `session_id` or `linkedSessionId`

2. **Callback Detection**: Listens for `run_start` events on finished sessions
   ```typescript
   if (event.event_type === 'run_start') {
     const wasFinished = currentAgentStatus === 'finished';
     if (wasFinished && !currentPendingMessageId) {
       // Callback resume detected!
     }
   }
   ```

3. **Message Refresh**: When callback resume is detected:
   - Fetches all session events from the API
   - Converts events to chat messages (includes user message that triggered callback)
   - Adds a pending message indicator for the assistant response
   - Displays the assistant response when it arrives

4. **Stale Closure Prevention**: Uses refs (`agentStatusRef`, `sessionIdRef`, etc.) to ensure WebSocket callbacks always have current state values

## State Management

### ChatContext (App Level)

Chat state is managed in `ChatContext` which is mounted at the App level. This provides:

- **Tab navigation persistence**: Chat state persists when switching between dashboard tabs
- **Background message handling**: WebSocket messages are processed even when on other tabs
- **Refs for callbacks**: Uses refs to avoid stale closures in WebSocket handlers

### What IS Persisted (in memory)
- Chat messages displayed in the UI
- Current session ID (and linked session ID)
- Selected agent blueprint
- Agent status

### What is NOT Persisted (across page refresh)
- Chat UI state is stored in React state only
- Refreshing the page clears the chat UI
- The `session_id` reference is lost on refresh (no localStorage)

## Features

- **Agent Selection**: Dropdown to choose agent blueprint (or "Generic Agent") with refresh button
- **Connection Status**: Shows SSE connected/disconnected state
- **New Chat**: Clears UI and starts fresh session
- **Markdown Rendering**: Agent responses rendered with ReactMarkdown
- **Auto-scroll**: Messages area scrolls to bottom on new messages
- **Tab Persistence**: Chat state maintained when navigating between tabs

## Configuration

Set the Agent Coordinator URL via environment variable:
```bash
VITE_AGENT_ORCHESTRATOR_API_URL=http://localhost:8765
```

Or it defaults to `http://localhost:8765`.
